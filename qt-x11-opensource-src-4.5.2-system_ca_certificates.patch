diff -up qt-x11-opensource-src-4.5.2/src/network/ssl/qsslsocket_openssl.cpp.me qt-x11-opensource-src-4.5.2/src/network/ssl/qsslsocket_openssl.cpp
--- qt-x11-opensource-src-4.5.2/src/network/ssl/qsslsocket_openssl.cpp.me	2009-09-09 14:28:38.000000000 +0200
+++ qt-x11-opensource-src-4.5.2/src/network/ssl/qsslsocket_openssl.cpp	2009-09-09 15:00:07.000000000 +0200
@@ -482,31 +482,20 @@ void QSslSocketPrivate::resetDefaultCiph
 
 QList<QSslCertificate> QSslSocketPrivate::systemCaCertificates()
 {
-#ifdef QQ_OS_UNIX
+    QFile caBundle;
+
+#ifdef Q_OS_UNIX
     // Check known locations for the system's default bundle.  ### On Windows,
     // we should use CAPI to find the bundle, and not rely on default unix
     // locations.
-    const char *standardLocations[] = {"/etc/ssl/certs/",
-#if 0
-                                       // KDE uses KConfig for its SSL store,
-                                       // but it also stores the bundle at
-                                       // this location
-                                       "$HOME/.kde/share/apps/kssl/ca-bundle.crt",
-#endif
-                                       0};
-    const char **it = standardLocations;
-    QStringList nameFilter;
-    nameFilter << QLatin1String("*.pem") << QLatin1String("*.crt");
-    while (*it) {
-        if (QDirIterator(QLatin1String(*it), nameFilter).hasNext())
-            return certificatesFromPath(QLatin1String(*it));
-        ++it;
-    }
+    caBundle.setFileName(QLatin1String("/etc/pki/tls/certs/ca-bundle.crt"));
+    if (caBundle.open(QIODevice::ReadOnly | QIODevice::Text))
+        return QSslCertificate::fromDevice(&caBundle);
 #endif
 
     // Qt provides a default bundle when we cannot detect the system's default
     // bundle.
-    QFile caBundle(QLatin1String(":/trolltech/network/ssl/qt-ca-bundle.crt"));
+    caBundle.setFileName(QLatin1String(":/trolltech/network/ssl/qt-ca-bundle.crt"));
     if (caBundle.open(QIODevice::ReadOnly | QIODevice::Text))
         return QSslCertificate::fromDevice(&caBundle);
 
