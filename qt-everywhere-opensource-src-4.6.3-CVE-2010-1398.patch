diff -ur qt-everywhere-opensource-src-4.6.3/src/3rdparty/webkit/WebCore/dom/Element.cpp qt-everywhere-opensource-src-4.6.3-CVE-2010-1398/src/3rdparty/webkit/WebCore/dom/Element.cpp
--- qt-everywhere-opensource-src-4.6.3/src/3rdparty/webkit/WebCore/dom/Element.cpp	2010-06-02 04:03:12.000000000 +0200
+++ qt-everywhere-opensource-src-4.6.3-CVE-2010-1398/src/3rdparty/webkit/WebCore/dom/Element.cpp	2010-06-10 21:10:21.197317643 +0200
@@ -35,6 +35,7 @@
 #include "ClientRect.h"
 #include "ClientRectList.h"
 #include "Document.h"
+#include "DocumentFragment.h"
 #include "ElementRareData.h"
 #include "ExceptionCode.h"
 #include "FocusController.h"
@@ -42,6 +43,7 @@
 #include "FrameView.h"
 #include "HTMLElement.h"
 #include "HTMLNames.h"
+#include "HTMLTokenizer.h"
 #include "NamedNodeMap.h"
 #include "NodeList.h"
 #include "NodeRenderStyle.h"
@@ -49,6 +51,7 @@
 #include "RenderView.h"
 #include "TextIterator.h"
 #include "XMLNames.h"
+#include "XMLTokenizer.h"
 
 #if ENABLE(SVG)
 #include "SVGNames.h"
@@ -91,6 +94,51 @@
 {
     return new ElementRareData;
 }
+
+PassRefPtr<DocumentFragment> Element::createContextualFragment(const String& markup)
+{
+    RefPtr<DocumentFragment> fragment = DocumentFragment::create(document());
+    
+    if (document()->isHTMLDocument())
+        parseHTMLDocumentFragment(markup, fragment.get());
+    else {
+        if (!parseXMLDocumentFragment(markup, fragment.get(), this))
+            // FIXME: We should propagate a syntax error exception out here.
+            return 0;
+    }
+    
+    // Exceptions are ignored because none ought to happen here.
+    ExceptionCode ignoredExceptionCode;
+    
+    // We need to pop <html> and <body> elements and remove <head> to
+    // accommodate folks passing complete HTML documents to make the
+    // child of an element.
+    
+    RefPtr<Node> nextNode;
+    for (RefPtr<Node> node = fragment->firstChild(); node; node = nextNode) {
+        nextNode = node->nextSibling();
+        if (node->hasTagName(htmlTag) || node->hasTagName(bodyTag)) {
+            Node* firstChild = node->firstChild();
+            if (firstChild)
+                nextNode = firstChild;
+            RefPtr<Node> nextChild;
+            for (RefPtr<Node> child = firstChild; child; child = nextChild) {
+                nextChild = child->nextSibling();
+                node->removeChild(child.get(), ignoredExceptionCode);
+                ASSERT(!ignoredExceptionCode);
+                fragment->insertBefore(child, node.get(), ignoredExceptionCode);
+                ASSERT(!ignoredExceptionCode);
+            }
+            fragment->removeChild(node.get(), ignoredExceptionCode);
+            ASSERT(!ignoredExceptionCode);
+        } else if (node->hasTagName(headTag)) {
+            fragment->removeChild(node.get(), ignoredExceptionCode);
+            ASSERT(!ignoredExceptionCode);
+        }
+    }
+    
+    return fragment.release();
+}
     
 PassRefPtr<Node> Element::cloneNode(bool deep)
 {
diff -ur qt-everywhere-opensource-src-4.6.3/src/3rdparty/webkit/WebCore/dom/Element.h qt-everywhere-opensource-src-4.6.3-CVE-2010-1398/src/3rdparty/webkit/WebCore/dom/Element.h
--- qt-everywhere-opensource-src-4.6.3/src/3rdparty/webkit/WebCore/dom/Element.h	2010-06-02 04:03:12.000000000 +0200
+++ qt-everywhere-opensource-src-4.6.3-CVE-2010-1398/src/3rdparty/webkit/WebCore/dom/Element.h	2010-06-10 21:09:56.802317368 +0200
@@ -89,6 +89,8 @@
     DEFINE_ATTRIBUTE_EVENT_LISTENER(search);
     DEFINE_ATTRIBUTE_EVENT_LISTENER(selectstart);
 
+    virtual PassRefPtr<DocumentFragment> createContextualFragment(const String&);
+
     const AtomicString& getIDAttribute() const;
     bool hasAttribute(const QualifiedName&) const;
     const AtomicString& getAttribute(const QualifiedName&) const;
diff -ur qt-everywhere-opensource-src-4.6.3/src/3rdparty/webkit/WebCore/editing/markup.cpp qt-everywhere-opensource-src-4.6.3-CVE-2010-1398/src/3rdparty/webkit/WebCore/editing/markup.cpp
--- qt-everywhere-opensource-src-4.6.3/src/3rdparty/webkit/WebCore/editing/markup.cpp	2010-06-02 04:03:10.000000000 +0200
+++ qt-everywhere-opensource-src-4.6.3-CVE-2010-1398/src/3rdparty/webkit/WebCore/editing/markup.cpp	2010-06-10 21:05:12.880192498 +0200
@@ -1054,11 +1054,7 @@
 
 PassRefPtr<DocumentFragment> createFragmentFromMarkup(Document* document, const String& markup, const String& baseURL)
 {
-    ASSERT(document->documentElement()->isHTMLElement());
-    // FIXME: What if the document element is not an HTML element?
-    HTMLElement *element = static_cast<HTMLElement*>(document->documentElement());
-
-    RefPtr<DocumentFragment> fragment = element->createContextualFragment(markup);
+    RefPtr<DocumentFragment> fragment = document->documentElement()->createContextualFragment(markup);
 
     if (fragment && !baseURL.isEmpty() && baseURL != blankURL() && baseURL != document->baseURL())
         completeURLs(fragment.get(), baseURL);
diff -ur qt-everywhere-opensource-src-4.6.3/src/3rdparty/webkit/WebCore/html/HTMLElement.cpp qt-everywhere-opensource-src-4.6.3-CVE-2010-1398/src/3rdparty/webkit/WebCore/html/HTMLElement.cpp
--- qt-everywhere-opensource-src-4.6.3/src/3rdparty/webkit/WebCore/html/HTMLElement.cpp	2010-06-02 04:03:10.000000000 +0200
+++ qt-everywhere-opensource-src-4.6.3-CVE-2010-1398/src/3rdparty/webkit/WebCore/html/HTMLElement.cpp	2010-06-10 21:13:26.701317282 +0200
@@ -235,9 +235,9 @@
     return createMarkup(this);
 }
 
-PassRefPtr<DocumentFragment> HTMLElement::createContextualFragment(const String &html)
+PassRefPtr<DocumentFragment> HTMLElement::createContextualFragment(const String &markup)
 {
-    // the following is in accordance with the definition as used by IE
+    // The following is in accordance with the definition as used by IE.
     if (endTagRequirement() == TagStatusForbidden)
         return 0;
 
@@ -245,47 +245,7 @@
         hasLocalName(headTag) || hasLocalName(styleTag) || hasLocalName(titleTag))
         return 0;
 
-    RefPtr<DocumentFragment> fragment = DocumentFragment::create(document());
-    
-    if (document()->isHTMLDocument())
-         parseHTMLDocumentFragment(html, fragment.get());
-    else {
-        if (!parseXMLDocumentFragment(html, fragment.get(), this))
-            // FIXME: We should propagate a syntax error exception out here.
-            return 0;
-    }
-
-    // Exceptions are ignored because none ought to happen here.
-    int ignoredExceptionCode;
-
-    // we need to pop <html> and <body> elements and remove <head> to
-    // accommodate folks passing complete HTML documents to make the
-    // child of an element.
-
-    RefPtr<Node> nextNode;
-    for (RefPtr<Node> node = fragment->firstChild(); node; node = nextNode) {
-        nextNode = node->nextSibling();
-        if (node->hasTagName(htmlTag) || node->hasTagName(bodyTag)) {
-            Node *firstChild = node->firstChild();
-            if (firstChild)
-                nextNode = firstChild;
-            RefPtr<Node> nextChild;
-            for (RefPtr<Node> child = firstChild; child; child = nextChild) {
-                nextChild = child->nextSibling();
-                node->removeChild(child.get(), ignoredExceptionCode);
-                ASSERT(!ignoredExceptionCode);
-                fragment->insertBefore(child, node.get(), ignoredExceptionCode);
-                ASSERT(!ignoredExceptionCode);
-            }
-            fragment->removeChild(node.get(), ignoredExceptionCode);
-            ASSERT(!ignoredExceptionCode);
-        } else if (node->hasTagName(headTag)) {
-            fragment->removeChild(node.get(), ignoredExceptionCode);
-            ASSERT(!ignoredExceptionCode);
-        }
-    }
-
-    return fragment.release();
+    return Element::createContextualFragment(markup);
 }
 
 static inline bool hasOneChild(ContainerNode* node)
@@ -371,7 +331,7 @@
 
 void HTMLElement::setInnerText(const String& text, ExceptionCode& ec)
 {
-    // follow the IE specs about when this is allowed
+    // Follow the IE specs about when this is allowed.
     if (endTagRequirement() == TagStatusForbidden) {
         ec = NO_MODIFICATION_ALLOWED_ERR;
         return;
@@ -441,7 +401,7 @@
 
 void HTMLElement::setOuterText(const String &text, ExceptionCode& ec)
 {
-    // follow the IE specs about when this is allowed
+    // Follow the IE specs about when this is allowed.
     if (endTagRequirement() == TagStatusForbidden) {
         ec = NO_MODIFICATION_ALLOWED_ERR;
         return;
@@ -469,7 +429,7 @@
     if (ec)
         return;
 
-    // is previous node a text node? if so, merge into it
+    // Is previous node a text node? If so, merge into it.
     Node* prev = t->previousSibling();
     if (prev && prev->isTextNode()) {
         Text* textPrev = static_cast<Text*>(prev);
@@ -482,7 +442,7 @@
         t = textPrev;
     }
 
-    // is next node a text node? if so, merge it in
+    // Is next node a text node? If so, merge it in.
     Node* next = t->nextSibling();
     if (next && next->isTextNode()) {
         Text* textNext = static_cast<Text*>(next);
@@ -522,7 +482,7 @@
         return 0;
     }
     
-    // IE throws COM Exception E_INVALIDARG; this is the best DOM exception alternative
+    // IE throws COM Exception E_INVALIDARG; this is the best DOM exception alternative.
     ec = NOT_SUPPORTED_ERR;
     return 0;
 }
@@ -530,7 +490,7 @@
 Element* HTMLElement::insertAdjacentElement(const String& where, Element* newChild, ExceptionCode& ec)
 {
     if (!newChild) {
-        // IE throws COM Exception E_INVALIDARG; this is the best DOM exception alternative
+        // IE throws COM Exception E_INVALIDARG; this is the best DOM exception alternative.
         ec = TYPE_MISMATCH_ERR;
         return 0;
     }
@@ -567,8 +527,8 @@
 
 void HTMLElement::addHTMLAlignmentToStyledElement(StyledElement* element, MappedAttribute* attr)
 {
-    // vertical alignment with respect to the current baseline of the text
-    // right or left means floating images
+    // Vertical alignment with respect to the current baseline of the text
+    // right or left means floating images.
     int floatValue = CSSValueInvalid;
     int verticalAlignValue = CSSValueInvalid;
 
